#!/usr/bin/env python3

# ┌────────────────────────────────────────────────┐
# │ Type / Version : python / live                 │
# │ Author : Mark Hamilton │ Co-Pilot AI assisted  │
# │ Script Purpose : Generate MD docs from Scripts │
# │ Package : toolbox                              │
# └────────────────────────────────────────────────┘

import os
import re
import argparse

DOC_DIR = "docs"
os.makedirs(DOC_DIR, exist_ok=True)

def extract_metadata(script_path):
    with open(script_path, 'r') as f:
        content = f.read()

    def grep(pattern):
        match = re.search(pattern, content)
        return match.group(1).strip() if match else None

    metadata = {
        "tool_name": os.path.basename(script_path),
        "author": grep(r"# │ Author\s*:\s*(.+)"),
        "package": grep(r"# │ Package\s*:\s*(.+)"),
        "purpose": grep(r"# │ Script Purpose\s*:\s*(.+)"),
        "description": grep(r"# Description:\s*(.+)")
    }

    # Fallbacks
    if not metadata["description"]:
        metadata["description"] = metadata["purpose"] or "⚠️ No Description Available"
    if not metadata["author"]:
        metadata["author"] = "⚠️ Unknown Author"
    if not metadata["package"]:
        metadata["package"] = "⚠️ Unknown Package"

    # Extract flags
    flags = re.findall(r'case "\$1" in\s*\n\s*--(\w+)', content)
    metadata["flags"] = flags

    return metadata

def generate_markdown(meta, dry_run=False):
    md_path = os.path.join(DOC_DIR, f"{meta['tool_name']}.md")
    lines = [
        f"# {meta['tool_name']}\n",
        "## 📌 Purpose\n" + meta["description"] + "\n",
        "## 🧑‍💻 Author\n" + meta["author"] + "\n",
        "## 🧰 Package\n" + meta["package"] + "\n",
        "## ⚙️ CLI Arguments\n```",
        f"{meta['tool_name']} [{' '.join('--' + f for f in meta['flags'])}]",
        "```\n",
        "### 🔧 Flags"
    ]

    for flag in meta["flags"]:
        if flag == "dry-run":
            lines.append("- `--dry-run`: Simulates actions without executing")
        elif flag == "log":
            lines.append(f"- `--log`: Appends steps to `/var/log/{meta['tool_name']}.log`")
        elif flag == "hashmap":
            lines.append("- `--hashmap`: Generates hash and timestamp for audit trail")
        else:
            lines.append(f"- `--{flag}`: Description not available")

    lines.append("\n## 🧪 Example Usage")
    for flag in meta["flags"]:
        lines.append("```bash")
        lines.append(f"{meta['tool_name']} --{flag}")
        lines.append("```")

    lines += [
        "\n## 📂 Output Structure",
        f"- `/var/log/{meta['tool_name']}.log`: Log file (if `--log`)",
        f"- `.hashmap/{meta['tool_name']}.hash`: SHA256 hash (if `--hashmap`)",
        f"- `.hashmap/{meta['tool_name']}.timestamp`: Timestamp (if `--hashmap`)",
        "\n## 🔍 Traceability Features",
        "- Dry-run mode for safe simulation",
        "- Logging for operational audit",
        "- Hash-based integrity check",
        "\n## 🔗 Related Tools",
        "Auto-linked via `tool-box.md`",
        "\n## 🧠 Contributor Notes",
        "This documentation was generated by `tool-docgen.py` using AI-assisted analysis."
    ]

    if dry_run:
        print(f"\n📄 Preview of {meta['tool_name']}.md:\n")
        print("\n".join(lines))
    else:
        with open(md_path, 'w') as f:
            f.write("\n".join(lines))
        print(f"✅ Doc generated: {md_path}")

def main():
    parser = argparse.ArgumentParser(description="Generate Markdown docs for toolbox scripts.")
    parser.add_argument("target", help="Script file or directory")
    parser.add_argument("--dry-run", action="store_true", help="Preview output without writing")
    args = parser.parse_args()

    if os.path.isdir(args.target):
        for file in os.listdir(args.target):
            path = os.path.join(args.target, file)
            if os.path.isfile(path) and (file.endswith(".sh") or os.access(path, os.X_OK)):
                meta = extract_metadata(path)
                generate_markdown(meta, dry_run=args.dry_run)
    else:
        meta = extract_metadata(args.target)
        generate_markdown(meta, dry_run=args.dry_run)

if __name__ == "__main__":
    main()
